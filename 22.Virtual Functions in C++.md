---
layout: "post"
title: "Virtual Functions in C++"
date: 2025-04-04
categories: ["C++"]
tags: ["Virtual Functions", "Polymorphism", "override", "vtable", "Dynamic Dispatch", "Inheritance", "OOP"]
description: "Explains C++ virtual functions for achieving polymorphism, allowing derived classes to override base class methods using 'virtual' and 'override'."
author: "Vaibhav Deokar"
image: "/notes/cpp/img-data/cpp_thumbnail.jpg"
---
# ğŸ¥ C++ Virtual Functions
**Playlist Link:** [C++ Series by TheCherno](https://www.youtube.com/watch?v=9RJTQmK0YPI&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=10)  

---

## ğŸ“š **Introduction to Virtual Functions**  
**Video Reference:** [Start at 0:00](https://youtu.be/oIV2KchSyGQ?t=0)  
Virtual functions enable **polymorphism** in C++. They allow subclasses to **override** base class methods, ensuring the correct function is called at runtime, even when using base class pointers.  

### ğŸ› ï¸ **Why Use Virtual Functions?**  
- Resolve incorrect method calls when using **polymorphism** (e.g., treating a `Player` as an `Entity`).  
- Enable **dynamic dispatch** via a *vtable* (virtual method table).  

---

## ğŸ§© **Example: Base Class (Entity) Without Virtual**  
**Video Reference:** [2:02](https://youtu.be/oIV2KchSyGQ?t=122)  
```cpp  
class Entity {  
public:  
    std::string GetName() { return "Entity"; } // âŒ Not virtual  
};  

class Player : public Entity {  
private:  
    std::string m_Name;  
public:  
    Player(const std::string& name) : m_Name(name) {}  
    std::string GetName() { return m_Name; } // âŒ Override not enforced  
};  

// Usage:  
Entity* entity = new Player("Cherno");  
std::cout << entity->GetName(); // Prints "Entity" (WRONG!)  
```  
**Problem:** Without `virtual`, the base class method is called, ignoring the subclass implementation.  

---

## ğŸ”„ **Fixing with Virtual Functions**  
**Video Reference:** [4:04](https://youtu.be/oIV2KchSyGQ?t=244)  
```cpp  
class Entity {  
public:  
    virtual std::string GetName() { return "Entity"; } // âœ… Mark as virtual  
};  

class Player : public Entity {  
private:  
    std::string m_Name;  
public:  
    Player(const std::string& name) : m_Name(name) {}  
    std::string GetName() override { return m_Name; } // âœ… Use 'override'  
};  

// Usage:  
Entity* entity = new Player("Cherno");  
std::cout << entity->GetName(); // Prints "Cherno" (CORRECT!)  
```  

### âœ… **Key Points:**  
1. `virtual` in the base class enables dynamic dispatch.  
2. `override` in derived classes (C++11+):  
   - Improves readability.  
   - Prevents typos/errors (e.g., `GetName` vs `Getname`).  

---

## âš™ï¸ **Runtime Costs of Virtual Functions**  
**Video Reference:** [5:26](https://youtu.be/oIV2KchSyGQ?t=326)  
1. **Memory Overhead:**  
   - Each object stores a **vtable pointer** (8 bytes on 64-bit systems).  
2. **Performance Overhead:**  
   - Indirect function call via vtable (~1-2 CPU cycles).  

### ğŸš¨ **When to Avoid Virtual Functions:**  
- Ultra-low-latency systems (e.g., embedded devices).  
- In hot loops where every cycle counts (rare in most applications).  

---

## ğŸ“Œ **Key Takeaways**  
1. Use `virtual` for methods needing **polymorphic behavior**.  
2. Always use `override` in derived classes for safety/clarity.  
3. Virtual functions are **low-cost** for most applications.  

ğŸ”— **Full Video:** [Virtual Functions in C++](https://youtu.be/oIV2KchSyGQ)  

--- 

**Need to revisit a concept? Jump directly to the video sections with the timestamped links above!** ğŸš€
